# 变量、作用域与内存

### 原始值与引用值

1. 原始值（primitive value）就是最简单的数据，引用值（reference value）则是由多个值构成的对象。
   1. 保存原始值的变量是按值（by value）访问的，因为我们操作的就是存储在变量中的实际值, 6种简单类型就是原始值
   2. 引用值,在操作对象时，实际上操作的是对该对象的引用（reference）而非实际的对象本身。为此，保存引用值的变量是按引用（by reference）访问的。引用值是保存在内存中的对象。与其他语言不同，JavaScript 不允许直接访问内存位置

   3. 动态属性
      1. 对于引用值而言，可以随时添加、修改和删除其属性和方法。
      2. 原始值不能有属性，尽管尝试给原始值添加属性不会报错。
      3. 原始值如果使用new初始化，就创建了object实例，但是行为类似原始值
      ```javascript
        let name1 = "Nicholas"; 
        let name2 = new String("Matt"); 
        name1.age = 27; 
        name2.age = 26; 
        console.log(name1.age); // undefined 
        console.log(name2.age); // 26 
        console.log(typeof name1); // string 
        console.log(typeof name2); // object
      ```
    4. 复制值
       1. 原始值是拷贝的形式，两者互不干扰
       2. 引用值复制的是指针，两者共用堆内存中的对象
    5. 传递参数
       1. 在函数中传递的参数，就是局部变量，和直接赋值变量没有区别。
    6. 确定类型
       1. typeof对原始值很有用，对引用值用处不大
          1. 判断函数的时候返回的是function
       2. a instanceof Object 返回的是布尔值，根据这个判断是否是一个类型.使用Object进行判断则永远是真

### 执行上下文与作用域

1. 执行上下文（以下简称“上下文”）的概念在 JavaScript 中是颇为重要的。变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的变量对象（variable object），而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问变量对象，但后台处理数据会用到它。
2. 全局上下文是最外层的上下文。根据 ECMAScript 实现的宿主环境，表示全局上下文的对象可能不一样。在浏览器中，全局上下文就是我们常说的 window 对象（第 12 章会详细介绍），因此所有通过 var 定义的全局变量和函数都会成为 window 对象的属性和方法。使用 let 和 const 的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。上下文在其所有代码都执行完毕后会被销毁，包括定义
在它上面的所有变量和函数（全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器）。
3. 执行上下文代码，会创建变量对象的一个作用域链,这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序,代码正在执行的上下文的变量对象始终位于作用域链的最前端,全局上下文的变量对象始终是作用域链的最后一个变量对象。
4. 每个上下文都是先从自身的变量开始搜索，可以搜索自己的上级上下文，不能搜索自己的下级，函数的参数也是当前上下文中的变量。
5. 作用域链增强
   1. try/catch 语句的 catch 块 和 with 语句 会导致在作用域链前端临时添加一个上下文, 这个上下文在代码执行后会被删除

6. 变量声明
   1. var 会被自动添加到最接近的上下文中，在函数中就是函数的局部上下文。如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文, 严格模式下会报错
   2. let 块级作用域，let 在 JavaScript 运行时中也会被提升，但由于“暂时性死区”（temporal dead zone）的缘故，实际上不能在声明之前使用 let 变量。因此，从写 JavaScript 代码的角度说，let 的提升跟 var是不一样的。
   3. const 是常量声明 除了必须在声明的时候初始化,并且在生命周期内无法被修改，其他的和let一致,如果想让对象内部的属性也无法修改，使用Object.freeze()，这样再给属性赋值时虽然不会报错，但会静默失败
      1. 由于 const 声明暗示变量的值是单一类型且不可修改，JavaScript 运行时编译器可以将其所有实例都替换成实际的值，而不会通过查询表进行变量查找。谷歌的 V8 引擎就执行这种优化。

7. 垃圾回收
   1. 标记清理
      1. 变量进入上下文，添加存在于上下文的标记，离开的时候，加上离开的标记，然后在一定的时间间隔后，清理他们
      2. 到了 2008 年，IE、Firefox、Opera、Chrome 和 Safari 都在自己的 JavaScript 实现中采用标记清理（或其变体），只是在运行垃圾回收的频率上有所差异。
   2. 引用计数
      1. 赋值引用值时，计数加1，覆盖后，减1
      2. 有循环引用的问题,需要将值置为null才可以解决
   3. 性能
      1. 垃圾回收的程序对性能的影响有时候很大，有些浏览器可以主动的出发垃圾回收，但是并不推荐这么做。
   4. 内存管理
      1. 因为桌面浏览器和移动浏览器的内存一般比桌面软件的要少很多，这通常是出于安全考虑的，所以需要将内存占用量保持在一个比较小的值，在全局变量和全局对象的属性中，如果数据不在必要，将他设置为null，释放它。
      2. const 和 let 都可以让垃圾回收程序尽早的回收内存
      3. 隐藏类和删除操作
         1. 隐藏类是V8引擎的优化策略，可以让两个实例共享同一个构造函数和原型
         2. 避免 JavaScript 的“先创建再补充”（ready-fire-aim）式的动态属性赋值，并在构造函数中一次性声明所有属性,如果动态的添加属性，会变成两个隐藏类，失去优化的特性，使用delete删除属性也是一样，最好直接将属性设置为null.
         ```javascript
        function Article(opt_author) { 
            this.title = 'Inauguration Ceremony Features Kazoo Band'; 
            this.author = opt_author; 
        } 
        let a1 = new Article(); 
        let a2 = new Article('Jake');
         ```
    5. 内存泄露
       1. 在函数中定义了全局变量
       2. 定时器引用了外部变量
       3. 闭包返回的函数，引用了外部的变量
       ```javascript
       let outer = function() { 
            let name = 'Jake'; 
            return function() { 
                return name; 
                }; 
        };
       ``` 
       4. 静态分配与对象池
          1. 先创建需要的一批对象，然后在需要的时候分配出去，不需要的时候归还给池子，这样子就占据着一定数量的内存，并且不会频繁的出发垃圾回收，但是这方法只有被垃圾回收严重拖后腿了才考虑，不然不考虑。