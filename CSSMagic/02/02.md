# 背景与边框

### 背景知识
1. rgba(红,绿,蓝,透明度)  rgb就是0-255之间的数值
2. hsla(色相,饱和度,亮度,透明度) 


### 正文

1. 半透明的边框希望显示的是元素下面的内容，而不是边框元素的背景内容
    1. 直接设置border的半透明颜色，显示的只能是当前元素的背景内容
    2. 使用background-clip: padding-box, 属性的意思是，在什么范围内剪裁背景，默认是border-box,就是在边框边缘剪裁背景，就不会延伸到边框之外了，现在改成padding-box,意思就是在内边距的范围内，就将背景剪裁，不会影响到边框。

2. 多重边框的实现
    1. 通过box-shadow实现
        1. 投影和边框的行为完全不同，只能通过自己计算宽高，将投影占的位置模拟出来，也可以使用inset关键字，投影会变成内投影
        2. 不响应书店的悬停或者点击
    2. 通过outline实现
        1. 好处在于可以通过outline-offset 设置与border的位置关系
        2. 也是不占据空间的，并且没办法跟随Border进行圆角。
        3. 只能实现两层边框的样式


> 我们希望对背景图片进行偏移定位，并且留出一些尺寸的内边距效果，并且需要在尺寸不固定的时候做到.
3. 灵活的背景定位
    1. background-position 的扩展语法方案
        1. 缺点是需要支持一个回退方案，防止浏览器不支持
    2. background-origin
        1. 将原来的以padding的范围为边距，改成content-box, 以内容为边距设置背景图片，这样子就可以享受到padding带来的便利。
    3. 通过calc函数进行计算,赋值给background-position



4. 边框内圆角，就是外部边框保持直角，内部边框进行圆角
    1. 通过outline实现，然后使用box-shadow 填充outline和border之前的缝隙。
    2. 使用勾股定理计算最小的shadow边界

5. 条纹背景
    1. 通过linear-gradient 实现
        1. 如果将颜色的位置设置为一样的，那么就会有一个无限趋近于没有的过渡，就会有条纹的效果
        2. 如果后面的位置没有设置，就会设置成前面位置的最大的值。
        3. 这个位置表示的是颜色的中间点，从这个点开始，将会有变化。(这里的理解会比较难，只能意会了)
        4. 斜的条纹可以使用repeating-linear-gradient来达成.
        5. 如果条纹的颜色有相关性，那可以在背景颜色上设置，然后条纹的颜色用白色的半透明遮罩来制作，更显得专业。

6. 复杂的背景图案
    1. 此处使用SVG是一个更好的方法，代码的复杂度更加的低
        1. 提到了一个data URI的方法，这是一个可以让你将图片转换为一串固定格式代码的协议，可以在浏览器中直接打开，并且解析后加载出来。
            1. 不需要经过请求
            2. 会消耗cpu解析，移动端需要衡量性能
            3. 无法懒加载
            4. 无法被浏览器自动缓存，所以多用于css中，css会被浏览器缓存。

7. 伪随机背景
    通过数学公式进行平铺背景图片的方式。

8. 连续的图像边框
    1. 可以使用图片加上渐变图片的方式，创造出边框图案，并且不会拉伸
    2. border-image 更加适合于创建单边的图案，或者是固定的宽高图案,会很便捷和方便。